"""
Process란?
    실행(executing, running)중인 프로그램
    PCB를 지닌 프로그램
    프로그램 카운터를 지닌 프로그램
    능동적 개체(entity)로, 순차적으로 수행하는 프로그램

OS가 담당하는 프로스세스 관리 기능
    1. 사용자 프로세스와 시스템 프로세스의 생성과 삭제
    2. 프로세스의 일시 중지와 재수행
    3. 프로세스 스케줄링
    4. 프로세스의 동기화
    5. 프로세스간 통신
    6. 교착상태 처리

제시 -> 보류 -> 준비완료 -><-(대기, 실행, 완료)
먼저 작업이 시스템에 제시 되면 SPOOLer에 의해 디스크에 수록되어 보류 상태가 된 후,
시행될 프로세스로 만들어 준비완료 리스트의 뒤에 삽입된다.

traffic controller (프로세스에 대한 상태와 정보를 조사 및 통보 담당자)
    dispatch    : 준비 -> 실행
    timer runout: 실행 -> 준비 (예: 인터럽트가 발생했을 때)
    block       : 실행 -> 대기 (예: 입출력 처리 요청 발생 및 자식 프로세스가 종료 대기를 할 때)
    wake-up     : 대기 -> 준비 (I/O가 완료되었을 때)

PCB의 구성형태 (https://m.blog.naver.com/skout123/50155850579)
    1. 프로세스의 현재상태(실행, 준비완료, 대기)
    2. 프로세스의 고유 번호(identifier)
    3. 프로세스의 우선 순위
    4. 프로세스가 적재된 기억장치의 주소를 가지는 포인터
    5. 할당된 자원을 가리키는 포인터
    6. CPU의 각종 레지스터 상태를 저장하기 위한 공간

UNIX 환경에서 프로세스를 생성시키는 함수는 fork()이다.
하나의 임의의 프로그램이 실행하는 도중에 fork 함수가 실행이 되면,

==============================프로세스 스케쥴링==============================
https://m.blog.naver.com/skout123/50155879799

단계별 스케줄링
    한 번에 끝내는 이미지 (https://m.blog.naver.com/skout123/50155879799?view=img_1)
    1. 상위 단계 스케줄링
        어떤 작업에게 시스템의 자원들을 차지할 수 있도록 할 것인가를 결정한다.
        어떤 작업들이 그 시스템에 들어오는 것을 승인을 해준다.
        때로는 작업 스케줄링(job), 승인(admission) 스케줄링이라고 불린다.

    2. 중간 단계 스케줄링
        어떤 프로세스들에게 cpu를 차지할 수 있도록 할 것인가를 결정한다.
        중간 단계의 스케줄러는 원활한 시스템 작동과 시스템 전체의 성능 향상을 위하여
        시스템 부하(load) 내에서 짧은 순간에 프로세스들에 대한 일시적인 활동의 중단 및 재개를 수행한다.
        따라서, 시스템에서의 작업 승인과 이들 작업에 대한 cpu 할당 사이에서 버퍼 역할을 한다.

    3. 하위 단계 스케줄링
        cpu가 다음 프로세스를 받아들일 수 있을때.
        어떤 준비 완료(ready process) 프로세스에게 cpu를 할당할 것인가를 결정한다.
        또한, 실제로 cpu를 이 프로세스에 할당해 준다.

        하위 단계 스케줄링은 디스패처에 의해서 매 초 여러번 작동한다.
        따라서 디스패처는 주기억장치 내에 항상 적재되어 있어야 한다.

선점/비선점 스케줄링
    비선점 스케줄링일 경우에는, 하나의 프로세스에 cpu가 할당되면
    그 프로세스의 수행이 끝날 때까지 cpu는 그 프로세스로부터 빠져 나올 수 없다.

    선점 스케줄링일 경우에는, 하나의 프로세스가 cpu를 차지하고 있을 때
    다른 프로세스가 현재 수행 중인 프로세스를 중지시키고 자신이 cpu를 차지할 수 있는 경우이다.

    선점 스케줄링은 높은 우선순위를 가진 프로세스들이 빠른 처리를 요구하는 시스템에서 유용하다.
    하지만 선점 스케줄링은 문맥 교환등으로 인한 오버헤드를 초래하게 된다.

    선점을 효과적으로 하기 위해서는 많은 프로세스들이 주기억장치 내에 있어야 하고,
    cpu가 사용 가능해질 때마다 준비완료 상태에 있는 프로세스가 있어야 한다.
    모든 프로세스들에 대한 대우는 공정하며, 도중에 높은 우선순위의 작업이 입력되더라도 대기 중인 작업들이 영향을 받지 않으므로
    응답 시간을 쉽게 예측할 수 있다.

우선순위(priority) 스케줄링
    각 프로세스에게 우선순위를 부여하여 우선순위가 높은 순서대로 처리하는 방법
    이 때 우선순위는 시스템 메커니즘에 의하여 자동적으로 할당되거나 외부적으로 할당될 수 있다.

    우선순위 기법에는 정적인 방법과 동적인 방법 두 가지가 있다.
    정적 우선순위(static priority) 기법
        실행이 쉽고 상대적으로 오버헤드는 적으나,
        주위 여건의 변화에 적응하지 않고 우선순위를 바꾸지 않는다.

    동적 우선순위(dynamic priority)
        각 프로세스에 부여된 처음의 우선순위는 필요에 따라 재구성되어 잠시 동안만 그 순위를 다시 조정할 수 있다.
        정적 방법보다 복잡하고 오버헤드가 많아지지만, 시스템의 응답도를 증가시켜 처리 효율을 높인다.
        동적 우선순위는 변화에 적응한다.

기한부(deadline) 스케줄링
    작업들이 명시된 시간 내에 완료되도록 계획한다.
    시간 내에 작업이 완료가 되면 매우 효용성이 높지만, 완료가 되지 않는다면 쓸모가 없어진다.


다중 프로세서 스케줄링
    1)
        각 프로세서가 스스로 스케줄링하며, 공동 준비 큐를 조사하여 실행할 프로세스를 선택한다.
    2)
        한 프로세서가 다른 프로세서를 위한 스케줄러로서 지정되어
        주-종 구조를 구성하여 문제를 해결한다.


FCFS(First Come First Served) 스케줄링
    가장 간단한 스케줄링 방식으로서 비선점 스케줄링 방법중 하나이다.

cpu burst란 cpu를 사용하는 구간이다.
i/o burst란 프로세스의 실행 중에 i/o 작업이 끝날 때까지의 구간이다.
프로세스 실행은 cpu 실행과 입/출력 대기의 cycle로 구성된다. 프로세스는 이 둘 상태를 왔다갔다 하는 것이다.
block이나 실행->종료 되었을 때, 프로세스가 스스로 cpu를 반환하기에 비선점 스케쥴링이 발생
timer runout or wake-up 되었을 땐 선점 스케줄링 방식이다.


대기 시간
실행 시간
반환 시간 = 대기 시간 + 실행 시간

fcfs(먼저 들어온 순서대로 수행), sjf(수행 시간 짧은 것부터 수행) (비선점 스케줄링)
우선순위 스케줄링(선점, 비선점)
    주요 문제)
        1. 무한대기
        2. 기아 현상

    무한대기에 대한 해결법)
        aging 기법:
        오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 방법이다.

    우선순위가 평가될 수 있는 기준
        cpu 버스트
        내부적 우선순위 (제한 시간, 메모리 요구량, 개방된 파일의 수 등)
        외부적 우선순위 (프로세스의 중요성, 정책적인 요인 등)

round-robin 선점 스케줄링
    시분할 시스템을 위한 선점 스케줄링 방식
        각 프로세스는 같은 크기의 cpu 시간을 할당받는다.
        시간이 만료된 실행 중이던 프로세스는 준비 완료 리스트(queue)의 가장 뒤로 보내진다.

        할당 시간이 굉장히 중요하다. (평균 10ms~100ms)
        할당 시간이 너무 적으면 context switching 때문에 overhead가 심해진다.
        할당 시간이 너무 많으면 효율이 안 좋아진다.

그 이외 스케줄링들
HRN, Multilevel queue(선점 스케줄링), SRT(선점 스케줄링) 등등




==============================쓰레드(Thread)==============================
https://m.blog.naver.com/skout123/50156096132

자인의 스택, 프로그램 포인터,자신의 레지스터들, 자신의 주소 공간

multi process: 하나 이상의 프로세서가 작업을 병렬처리 하는 것

context switching cost
    cache initialize
    memory mapping initialize
    kernel is running always(for access memory)

    동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태(context)를 보관하고, 대기하고
    있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.
ㄴㄴ
"""